#+Title: Testning och Debugging
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2023-12-08
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t H:2
#+STARTUP: beamer

#+LATEX_CLASS_OPTIONS: [10pt,t,a4paper]
#+BEAMER_THEME: BTH_msv

* Introduktion
- Thomas & Hunt: *Kapitel 7: While you are Coding*
- Thomas & Hunt: Kapitel 3; topic 20: Debugging
- Thomas & Hunt: Kapitel 9; topic 51: Pragmatic Starter Kit

* St√§da din Arbetsplats
- I en fabrik h√§nder ofta olyckor och man g√∂r misstag n√§r
  - saker st√•r i v√§gen,
  - det √§r skr√§p p√• golvet,
  - verktyg st√•r inte d√§r de skall g√∂ra, osv.

- Arbete tar l√§ngre tid n√§r man f√∂rst m√•ste
  - rensa upp en arbetsyta
  - leta efter verktygen
  - leta efter materiel som skall anv√§ndas
  - osv.
* 5S
I Japan introducerades begreppet *5S*
  - Sort :: G√• igenom allt materiel och alla verktyg och plocka bort det som inte anv√§nds
    - L√§ttare att f√• en √∂verblick √∂ver det som √§r kvar
    - Logiskt ordnat
    - L√§ttare att se vad som saknas, beh√∂ver best√§llas mer av, mm.
    - Mer effektiv anv√§ndning av arbetsyta
    - S√§krare eftersom det finns f√§rre hinder.
  - Set in Order :: Placera det som √§r kvar s√• att de l√§tt kan hittas n√§r de beh√∂ver anv√§ndas
    - L√§tt att hitta
    - L√§tt att n√•
    - L√§tt att n√• p√• ett s√§kert s√§tt
  - Shine :: St√§da arbetsplatsen regelbundet
    - S√§krare arbetsplats
    - Trevligare arbetsplats
    - St√§da bort det som √§r trasigt och f√∂rbrukat
    - L√§tt att se n√§r n√•got inte √§r som det skall.
  - Standardize :: Etablera rutiner f√∂r n√§r och hur man Sort, Set in Order, och Shine.
    - Etablera en arbetskultur
    - Alla vet vilka ansvar de har
    - √Ñven i en n√∂dsituation
  - Sustain :: G√∂r allt det ovanst√•ende till en vana.
    - "Do without being told"
* 5S och Mjukvara
- Sort :: Sortera det som anv√§nds, plocka bort det som inte anv√§nds
  - Vilka verktyg anv√§nder du faktiskt?
  - Vilka ramverk/plugins beh√∂vs faktiskt?
  - Vilka ~#includes~ anv√§nder du egentligen?
  - Vilka delar av programvaran anv√§nds inte l√§ngre av kunderna?
  - Vilka delar av programvaran har du levererat till vilken kund?
- Set in Order :: Placera det som √§r kvar s√• att det √§r l√§tt att hitta
  - Script f√∂r att s√§tta upp en ny utvecklingsmilj√∂
  - √ñverlever √§ndringar en reboot?
  - Konfigurationshantera /allt/, inklusive konfigurationen i sig sj√§lv.
  - Fokus p√• /flow/. Ett enda kommando f√∂r en ny server eller databas, rollback av databasen eller arbetsplatsen.
  - Snygga till koden s√• den √§r l√§tt att f√∂rst√•
- Shine :: St√§da arbetsplatsen regelbundet
  - Ny feature \rightarrow ny branch + rollback av databas och arbetsplats.
  - Snygga till koden s√• den √§r l√§tt att f√∂rst√•
- Standardize :: Etablera rutiner
  - Processdokumentation
    - ny utvecklingsiteration
    - rollback av arbetsplatsen
    - drifts√§ttning av applikationen
    - *Regler f√∂r vem som f√•r g√∂ra vad*
- Sustain :: G√∂r det som en vana
  - Continuous Build / Integration / Deployment
    - Verktyg som testar automatiskt n√§r du g√∂r en commit.
  - Skapar trygghet f√∂r utvecklare: Testerna f√•ngar (f√∂rhoppningsvis) dina misstag.
  - L√§ttl√§st kod == l√§ttare att se buggarna.
  - Skapa tester som en del av det normala arbetsfl√∂det
    - Del av utveckling
    - Del av fels√∂kning
    - /Konfigurationshantera testkoden!/
  - Script och makron f√∂r att skapa nya filer (kommer r√§tt ~#includes~ med? I samma ordning?)
* Shine: Refactoring
/Refactoring/ handlar om att man f√∂rb√§ttrar programkoden /utan att f√∂r√§ndra funktionaliteten/

- L√§sbarhet (t.ex. d√∂p om variabler)
- Underh√•llbarhet (t.ex. strukturera om designen)

- [ ] You leave the code cleaner than you found it.
- [ ] There is no new functionality added together with a refactoring
- [ ] All existing tests still pass after refactoring
* Ren kod
- [ ] Obvious to other programmers
  - Reasonable size of each component/class/method
  - Good names for classes attributes, methods, variables
- [ ] Does not contain duplicated code
- [ ] Does not contain unnecessary classes
- [ ] Passes all tests

\rightarrow cheaper to maintain
* Smutsig Kod -- Teknisk Skuld
(The term /Technical Debt/ is coined by Ward Cunningham)

- Quick fixes that we promise to ourselves that we are going to fix later.
- Goldplating that has no use right now but which we still need to maintain.

- Business Pressure
  - Ship it! We'll fix the details later\dots
  - Botch it so it more or less works. Hide the parts that are "under construction"
- Lack of Understanding of Consequences of Technical Debt
  - Technical Debt cost in time and resources for /all/ development.

- Lack of adherence to original design decisions
  - maybe forgotten?
  - architecture decay
  - brittle system
  - changes in one component/class affect other classes
  - \rightarrow time to trace and understand effect of changes
- Lack of documentation
  - How can you adhere to orignal design decisions if they are not documented?
  - Training of new employees
- Lack of interaction between team members
  - Shared understanding of design decisions means stricter adherence and less brittle systems

- Lack of tests
  - (Automated) tests bring direct feedback on what works or not.
* Code Smells
- Originally by Martin Fowler. 
- Can be summarised as "You know all the bad things your OO design teacher told you not to do? Well, don't!"

Examples
- Bloaters :: Code that grows too long \rightarrow low cohesion
  - long methods
  - long parameter lists
  - large classes
  - using primitives instead of small objects
- Object Orientation Abusers :: incorrect use of object oriented programming principles
  - Classes that do the same things but with different method names
  - Classes that only partially implement the interface from a superclass
  - Long and elaborate switch statements rather than relying on polymorphism
- Change Preventers :: Responsibilities are scattered through code so you need to change several places at once
  - When many methods need to be edited for a single change (e.g. adding a new product type)
  - Parallel inheritance hierarchies: Adding a class in one hierarchy means you also need to add a class in another hierarchy
- Dispensables :: Pointless code or text that does not contribute anything
  - Too many comments
  - Duplicate code
  - Dead Code
  - Classes that no longer do anything meaningful
  - Adding classes or inheritance hierarchies for future needs
- Couplers :: Things that tie classes too closely together
  - Using data in other classes (more than your own data)
  - Message chains =myFancyObject->getFrobnicator()->createFluxCapacitor()->initiate()=
* N√§r skall man strukturera om
Tre steg:
1. F√∂rsta g√•ngen, bara se till att det funkar
2. Andra g√•ngen du g√∂r n√•got liknande, k√§nn igen att det √§r likt men g√∂r det √§nd√•
3. Tredje g√•ngen -- Strukturera om!

N√§r du l√§gger till en feature
- Refactor under tiden du l√§ser den existerande koden som en del av att f√∂rst√• den

N√§r du fixar en bug
- St√§da upp koden under tiden du letar efter buggen

Kodgranskningar
- Regelbunden aktivitet med syfte att st√§da upp koden

*Arbeta lite med omstrukturering hela tiden*
* Refactoring Techniques :overview:
(A selection that has a design impact: There are many more techniques for how to write clearer code /within/ methods)

- Break out code into new methods to simplify the code
- Move methods and attributes to the class that should be responsible for them
- Remove classes that do not have any responsibilities

- Hide delegates to avoid method chains. If you are just "object hopping" to reach the right object, then you know too much about the design.
- Use wrapper classes to add functionality to libraries.
- Use getters and setters to access data
- Keep code from different layers/components separate. Duplicate data that should pass between components.

- Introduce classes to maintain collections (xxxManager, xxxContainer, \dots)
- Use Design Patterns instead of if-then-else chains.
- Create methods for complex if-then-else statements: =if condition() then trueCondition() else falseCondition()=
- Always return a meaningful object (e.g. a Null Object)

- Rename classes/methods/parameters/attributes/variables to meaningful and readable names

- Separate queries from modifiers \rightarrow avoid side effects in code
- Parameterise method (from =frobnicateA(), frobnicateB(), \dots= to =frobnicate(type)= 
- Replace complex constructor with a factory method.

- Apply Design Patterns
- Apply Fundamental Object Oriented Design Principles

* 5S och Testning

En stor del i att f√• 5S att fungera √§r att man har bra rutiner f√∂r *testning*

- Testning m√•ste vara en kontinuerlig vana
- V√§ltestad kod ger trygghet
- Trygghet ger l√§ttr√∂rlighet

* Vart √§r vi p√• v√§g?
- Cheshire-katten i Alice i Underlandet: 
  /Om du inte vet vart du √§r p√• v√§g s√• spelar det ingen roll vilket h√•ll du g√•r!/

- Testning som ett s√§tt att f√∂rst√• kraven
- Testning som ett s√§tt att best√§mma gr√§nssnittet f√∂r en komponent/klass/metod
* Manuell Testning
G√∂rs hela tiden, delvis undermedvetet och delvis konkret:

1. Vi best√§mmer oss f√∂r att skriva en metod, t.ex. ~Date calculateShippingDate(Packet thePacket)~
2. Vi funderar p√•:
   - Vilka parametrar har metoden, vad betyder de?
   - Vad kan g√• fel med parametrarna? Hur uppt√§cker vi det?
   - Vad skall metoden egentligen g√∂ra?
   - Vad skall metoden returnera?
   - Hur hanterar vi om det blir fel?
3. Vi skriver en f√∂rsta version av metoden.
4. Vi testar genom att anropa metoden med lite olika inparametrar.
   - Vi skriver ut lite resultat med ~console.log()~ och inspekterar manuellt att det verkar st√§mma.
   - St√§mmer v√•ra antaganden i steg 2? Annars g√• tillbaka till steg (2) och uppdatera.
5. √Ñr vi klara? Om inte, skriv mer av metoden och g√• tillbaka till steg (4)

Utmaningar
- Vi minns inte vad vi redan testat
- Vi har ingen √∂vergripande strategi f√∂r vilka v√§rden p√• parametrar vi vill testa
- Vi har ingen √∂vergripande strategi f√∂r vilka returv√§rden vi vill testa
* Testramverk
- P√• den h√§r niv√•n √§r det "enkelt" att skriva testkod. /Unit-Testing/
- *Utmaningen √§r att spara testerna, strukturera, och dokumentera dem.*
- Till detta finns speciella testramverk
  - Ofta integrerade i utvecklingsmilj√∂erna
  - G√∂r det lika enkelt att testa som att kompilera
  - Kan hj√§lpa till att generera data (property-based testing)
- Testdriven utveckling (TDD -- Test-Driven Development)

#+begin_src c++
TEST(SceneTests, listAvailableElementsRigtNumberOfElements) {
	Scene bilbliotkek;
	GameObject testObject("testObject");
	
	
	std::vector<GameObject> elements =bilbliotkek.listAvailableElements();
	
	ASSERT_EQ(elements.size(),1);
	ASSERT_EQ(elements[0]==testObject,1);
}
#+end_src

#+begin_src Cucumber
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario: Sunday isn't Friday
    Given today is Sunday
    When I ask whether it's Friday yet
    Then I should be told "Nope"
#+end_src
* A Software Tester walks into a bar...
A Software Tester walks into a bar and orders a beer.
- Then they orders -1 beers
- orders 999999999 beers
- orders a duck
- orders 0 beers
- orders a sdlkfjhkjsdhgfk
- orders ~null~

... Warming up. Let's try some edge cases:

- Orders 3 friends to come over for some fun.
- Unhooks the tap and orders a beer.
- Breaks all the glassware and orders a beer.
- Sets the bar on fire and orders a beer.
- Orders someone else a beer.
- Has everyone order a beer.
- Orders in russian.
- Orders a beer for later.
- Orders every beer.
- Walks into the bar backwards.
- Runs into the bar.
- Sits at the bar overnight doing nothing to see what happens.
- Tries to sell a beer.
- Quickly orders a second beer before the first is served.
- Interrupts the order midway and walks out. (~^C~)
- Orders a beer in IE6.
- Orders 1 ; select * from liquors; ‚Äî beers.
- Orders an apostrophe and walks out without paying the bill.
- Waits for someone else to order, stands between them and the bartender, takes the drink (Man In The Middle Attack)

... then sends all the beers back.
* Lita inte p√• anv√§ndare / Lita inte p√• dig sj√§lv!
- "I'm looking at a message on my screen: /No stupid idiot would ever get to this point/!"
- "Where did they find 10 stupid users?"
- https://github.com/kuronpawel/big-list-of-naughty-strings
- https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/

R√§kna med:
- felinmatningar
- r√§tt inmatning som du missf√∂rst√•tt
- medvetna f√∂rs√∂k att hacka ditt system
- att du beh√∂ver skydda: indata, utdata, debuginformation, konfigurationsfiler, header-data, \dots
* Fels√∂kning
Olika sorters fel
- Kompileringsfel :: programmet kan inte kompileras
- K√∂rfel :: programmet krashar eller kastar ett felmeddelande
- Designfel :: programmet ger fel svar
* Strategier f√∂r fels√∂kning
0. [@0] *L√§s felmeddelandet.*
1. √Öterskapa felet.
2. Vad √§r minsta m√∂jliga antal steg f√∂r att √•terskapa felet?
3. Skriv ett automatiserat test som √•terskapar felet.
* Debugging
- F√∂rst√• ett k√∂rande program
- Inspektera detaljer
  - /Vad √§r v√§rdet p√• den h√§r variabeln?/
  - /N√§r anropas den h√§r metoden?/
  - /Vilka v√§rden har parametrarna?/
  - /Vad h√§nder?/
  - /Kommer jag ens s√•h√§r l√•ngt?/

Verktyg:
- Papper & Penna
- Blandade utskrifter: ~console.log()~ ~printf()~ ~System.out.println()~
- Utskrifter via ett debug- eller log-ramverk (kanske med olika log-niv√•er, kanske med mer information)
- Stegvis exekvering: /Debugger/

* Sammanfattning
*H√•ll koden ren* och *L√•t det bli en vana att st√§da*
- Det √§r l√§ttare att se vad som √§r fel om ingenting √§r iv√§gen
- Refactoring: F√∂rb√§ttra koden utan att f√∂r√§ndra funktionaliteten.

*Anv√§nd automatiserade tester*
- Analysverktyg f√∂r att f√∂rst√• vad koden skall g√∂ra
- Fels√∂kningsverktyg f√∂r att utforska buggar
- Minne f√∂r att se till att buggarna inte dyker upp igen
 
*Bli bra p√• fels√∂kning*
- L√§sa felmeddelanden
- Debugging
* N√§sta F√∂rel√§sning
- Dokumentera din kod
- Sj√§lvdokumenterande kod
- Struktur som dokumentation
- Dokumentera din arbetsprocess
* √ñvning: Test och Debug :Practice:
** Introduktion till SorterTool
- https://codeberg.org/mickesv/SorterTool.git
- /SorterTool/ implementerar och testar ett par olika sorteringsalgoritmer.
- Det finns m√•nga olika s√§tt att sortera listor p√• som √§r olika snabba.
  - S√∂k p√• "Sorting out Sorting" f√∂r en gammal film (30 min) fr√•n 1980 som vi tvingades titta p√• i Datastruktur-kursen.
  - "Big-O" notation beskriver komplexiteten hos algoritmer.
- Exempel:
  - Insertion Sort: =O(n¬≤)= Flytta element ur v√§gen och stoppa in elementet p√• r√§tt plats
  - Selection Sort: =O(n¬≤)= Hitta det minsta v√§rdet och stoppa in det f√∂rst; b√∂rja om p√• element 2
  - Merge Sort: =O(n*log n)= Se till att varje par √§r ordnade, kombinera par =n= med =n+1=; upprepa.
  - QuickSort: =O(n*log n)=
    1. V√§lj ett element i mitten
    2. se till att alla till v√§nster √§r mindre och alla till h√∂ger st√∂rre
    3. upprepa f√∂r v√§nster och h√∂ger.
  - Bubble Sort: =O(n¬≤)= j√§mf√∂r varje element med alla andra och byt plats p√• alla element som inte redan √§r ordnade.
** Kom ig√•ng med √∂vningen
1. Klona SorterTool till din dator: https://codeberg.org/mickesv/SorterTool.git
2. √ñppna projektet i din IDE. Studera f√∂ljande filer:
   - ~src/Main.java~ f√∂r att snabbt kunna k√∂ra programmet
   - ~src/Sorter.java~ implementerar de olika sorteringsalgoritmerna.
   - ~Tests/SorterTest.java~ testar ~Sorter~.
3. K√∂r alla tester. Vad h√§nder?
4. K√∂r specifikt testet f√∂r ~bubbleSort()~
** Skaffa mer information

*L√§s meddelandet*

Nej, allvarligt! *L√§s meddelandet!*

- Vad kan ~AssertionFailedError~ betyda?
- I vilken fil och p√• vilken rad h√§nder det?
- Vad st√•r det p√• den raden?
  - R√§cker detta f√∂r att f√∂rst√• vad som gick fel?
  - Hur kan du ta reda p√• mer informaiton?
** Anv√§nd Debuggern
1. I filen ~SorterTest.java~, klicka p√• radnummret =49=; Det borde bytas till en liten stopp-skylt üõë
2. K√∂r nu testet f√∂r ~bubbleSort()~ i "Debug"-l√§ge.

Vad ser du nu i:
- kodf√∂nstret?
- f√∂nstret nedanf√∂r koden?

** Debug-f√∂nstret
[[./Debugging-annotated.png]]
- H√§r kan vi se varf√∂r testet misslyckas, men inte vad i koden som orsakade felet.
- /Ledtr√•d:/ Titta p√• arrayen ~out~ och alla v√§rden d√§r. Kan du se n√•got m√∂nster?
** Stega genom koden
1. Flytta break-punkten fr√•mn rad =49= till rad =47=.
2. K√∂r testet f√∂r ~bubbleSort()~ igen i Debug-l√§ge (Starta om testet n√§r du f√•r fr√•gan).

Viktiga verktyg f√∂r att stega genom koden:
- Continue/Resume :: K√∂r p√• till n√§sta breakpoint
- Step over :: K√∂r n√§sta instruktion, och stanna n√§r du kommer tillbaka
- Step in :: F√∂lj med in i n√§sta instruktion (oftast in i en metod)
- Step out :: K√∂r klart metoden du √§r i nu, och stanna n√§r du kommer tillbaka.

Anv√§nd *Step in* nu f√∂r att stega in i anropet till =srt.bubbleSort()= .
- Notera att variabelf√∂nstret √§ndras. Vad ser du d√§r nu? Varf√∂r?

Stega ett par varv i den inre for-loopen.
- raderna med ~for~ och ~if~ k√∂rs i varje varv.
- N√§r forts√§tter koden in i if-satsen? 
  - Vid vilka v√§rden p√• ~out[outer]~ respektive ~out[inner]~ ?

St√§mmer detta? (Det g√∂r det inte. Vad borde h√§nda?)

R√§tta till felet och forts√§tt debugga.
- Som du m√§rker verkar inte √§ndringen fungera.
- Du m√•ste /starta om/ testet f√∂r att det skall ta effekt.
** K√∂r om alla tester
- N√§r du nu har fixat felet s√• borde alla tester bli gr√∂na.
- Varf√∂r blir b√•de ~sort()~ och ~bubbleSort()~ gr√∂na? Du har ju bara fixat ~bubbleSort()~\dots
** Lek vidare p√• egen hand
- Kan du anv√§nda debuggern f√∂r att f√∂rst√• hur sorteringsalgoritmerna fungerar?
- Skriv din egen sorteringsalgoritm och testa den.
- Just nu finns det ett test f√∂r varje metod. Kan du ha fler tester f√∂r varje metod?
  - Vilka fler tester kan vara relevanta?
