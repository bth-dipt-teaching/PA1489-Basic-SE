#+Title: PA1489 Grundl칛ggande Mjukvaruutveckling -- Introduction
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2023-11-20
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t H:2
#+STARTUP: beamer

#+LATEX_CLASS_OPTIONS: [10pt,t,a4paper]
#+BEAMER_THEME: BTH_msv

* Introduktion
- Om Kursen
- En Pragmatisk Mjukvaruutvecklare
- En Pragmatisk Ansats
- Kort om exekverande program
* About Me: Mikael Svahnberg
#+ATTR_LATEX: :height 6cm
#+ATTR_ORG: :width 300
[[file:~/Documents/Personal/avatar.png]]


- Assistant Professor, PhD in Software Engineering
- mailto:Mikael.Svahnberg@bth.se
- https://sites.google.com/site/mikaelsvahnberg/
- Interests:
  - Software Architectures, Software Architecture Evaluation,
    Software Architecture Evolution, Requirements Engineering,
    Large Scale Requirements Engineering, Market-Driven Requirements Engineering,
    Software Product Lines, Software Reuse, Empirical Research Methodology,
    Software Engineering Decision Support, Static Code Analysis, Software Architecture Reconstruction
* Diskutera: Kursplan PA1489 :Discussion:
F칬ljande L칛randem친l examineras i kursen:

*Kunskap och F칬rst친else* Efter genomf칬rd kurs ska studenten kunna:
- Visa grundl칛ggande kunskaper i modern mjukvaruutveckling och containerbaserad mjukvaruutveckling genom att skriftligt beskriva och sammanfatta erfarenheter och observationer fr친n 칬vningar och projekt.

*F칛rdighet och f칬rm친ga*	Efter genomf칬rd kurs ska studenten kunna:
- Utifr친n en specifikation utveckla, dokumentera, och presentera ett mjukvaruprojekt som exekverar p친 ett f친tal kommunicerande containers.
- Fels칬ka ett program med hj칛lp av testkod och en debugger.
- Samarbeta runt ett gemensamt utvecklingsprojekt med hj칛lp av konfigurationsverktyg.
- Hantera de verktyg och utvecklingsmilj칬er som anv칛nds vid utveckling och fels칬kning med containerbaserad mjukvaruutveckling.

*V칛rderingsf칬rm친ga och f칬rh친llningss칛tt* 	Efter genomf칬rd kurs ska studenten kunna:
- Skriftligt reflektera 칬ver sina l칬sningar och sitt anv칛ndande av utvecklingsverktyg.
* TODO Struktur p친 Kursen
  - Modules
    - Readings
    - Lectures
      - Video Lectures
      - Classroom Lectures
    - Things to do
  - Assignments

OH-bilderna anv칛nder sig av en blandning av spr친k (svenska, engelska)
och programspr친k. Spr친ket och spr친ken 칛r verktyg som du kommer anv칛nda
dig av p친 olika vis under hela din studietid och din karri칛r. 칐vning
b칬rjar nu.
* Kursliteratur
D. Thomas, A. Hunt, The Pragmatic Programmer, 20th Anniversary Edition, 2020. ISBN-10: 0-13-595705-2

#+ATTR_ORG: :width 400
[[./Thomas-Hunt-2020-Pragmatic-Programmer.png]]

* TODO Inl칛mningsuppgifter
Two main themes:
1. Design (using Design Patterns)
2. Implement (according to a design and (some) standard libraries)

Delivered as a series of (more than two) assignments. */Some/ but not all are graded.*

Submissions:
- Submit your work in groups of 3-5 students.
- Deadlines on Canvas

Resubmissions:
- Within two weeks after course ends.
- Same dates as the re-exams
* TODO Verktyg
- You will need a Java Development Kit
  - e.g. OpenJDK https://openjdk.org/ .
- You may also wish to install a C/C++ compiler
  - e.g. gcc https://gcc.gnu.org/
- Make sure that the Java version you install is compatible with your IDE
  - e.g., BlueJ requires Java 11+.
- For the lazy, this is as good an opportunity as any to getting to know a ~make~ tool.
  - https://www.gnu.org/software/make/
  - https://cmake.org/ 

Examples of Development Environments:
- BlueJ https://www.bluej.org/
- IntelliJ https://www.jetbrains.com/idea/
- VS Codium https://vscodium.com/
- Emacs https://www.gnu.org/software/emacs/
- \dots
- Vim https://www.vim.org/

Examples of UML Modelling tools
- PlantUML http://plantuml.com/
- IntelliJ https://www.jetbrains.com/help/idea/class-diagram.html
- StarUML: http://staruml.io/
- VisualParadigm https://www.visual-paradigm.com/
- \dots

* En Pragmatisk Mjukvaruutvecklare
** En Pragmatisk Filosofi
[Thomas & Hunt, Kapitel 1]

- /It's Your Life/ :: It's your career. Your choice. Be good at it. Improve.
- /Commitment Culture/ :: Take responsibilty for what you do.
- /We live in a Changing World/ :: Recognise change and prepare to handle it.
- /Trade-offs are Inevitable/ :: Learn to recognise what is /good enough/
- /You work in a Team/ :: A team consisting of current colleagues /as well as your future self/
  - Your commitment is to the team /and/ the customer.
  - Communicate with your team.
  - Keep your code tidy and improve it.
  - Fight the inevitable decay.
** 칀tagandekultur: Gruppen och Du
*Gruppens 친tagande 칛r ditt 친tagande -- alla beh칬vs*

[[file:./IDogsleigh.jpg]]
** 칀tagande / Commitment Culture
 - *Gruppen* har 친tagit sig att leverera en produkt eller artefakt
   - Med en viss funktionalitet
   - Inom en viss budget
   - Vid en viss tidpunkt
   - Med en viss kvalitet
 - Som medlem i gruppen har *du* gjort samma 친tagande!

 [[file:./IKennedy-AskNot.jpg]]
** Teamwork och Individens Ansvar
 - 칀tagandekultur
   - Gemensam f칬rst친else f칬r uppgiften
   - Individens 친tagande mot gruppen
   - Gruppens 친tagande mot individen

 - F칬ruts칛ttningar
   - Har du n칬dv칛ndig kunskap om uppgiften?
   - Har du f칬rm친ga och vilja att ta p친 dig ansvaret?
** Delaktighet
- Gemensamma m친l
- Tillg친ng till n칬dv칛ndig information -- i tid
- F칬rst친else f칬r sammanhanget, individens bidrag till m친len
- M칬jlighet att uttrycka sin 친sikt
- M칬jlighet att p친verka sin situation
- Individuellt ansvar
  - f칬r /uppgiften/
  - f칬r /arbetss칛ttet/
  - f칬r /gruppen/

*N칛r det g친r fel:*
- Saknar gemensamma m친l, eller otydliga m친l
- Saknar styrning fr친n de som skall styra
- Saknar gemensamma processer, eller synkroniseringspunkter mellan processer
- Saknar 친tagande fr친n individerna
- Ingen tar eller avkr칛vs ansvar
- Ett f친tal dominerar diskussioner och beslut
- Beslut kommuniceras inte
- *\sum Kommunikationen fungerar inte*

** Entropi
- Minnens i gymnasiefysiken?
- I mjukvara: /software rot/
  - Tecnical debt :: Snabbfix nu, vi lovar oss sj칛lva att fixa senare
  - Architecture erosion / architecture decay :: Vi gl칬mmer den ursprungliga tanken och b칬rjar ta genv칛gar

Resultat:
- Det tar l칛ngre och l칛ngre tid att g칬ra 칛ven enklare saker i koden.
- Mer tid g친r 친t att f칬rst친 vad man skall g칬ra och vad konsekvenserna blir
- Nyanst칛llda beh칬ver mer och mer tid p친 sig innan de kan bli produktiva
- Du blir mer och mer missn칬jd med ditt arbete

Olika orsaker:
- Vi hinner inte g칬ra r칛tt
- Vi minns inte vad som 칛r r칛tt
- Vi f칬rst친r inte av koden och/eller dokumentationen vad som 칛r r칛tt
- Det finns ingen dokumentation om vad som 칛r r칛tt
- Vi bryr oss inte om vad som 칛r r칛tt f칬r systemet eller resten av teamet

Fundamentalt f칬r att motarbeta mjukvarur칬ta: *Fixa det som 칛r trasigt*
- Forts칛tt bry er
- Visa f칬r resten av teamet att det spelar roll
- Visa i projektplanen att det tar tid och kostar
- Ta inte s칬nder saker n칛r du bygger nytt. *Testa din kod*
** Forts칛tt Utvecklas
- Programvaruteknik f칬r칛ndras st칛ndigt
  - Nya verktyg, nya teknologier, nya ramverk, nya programspr친k
- Sluta inte l칛ra dig n칛r du tar examen
- Kurserna h칛nger ihop: anv칛nd det du l칛rt dig hela tiden.
- Bredda dig: L칛r dig lite om mycket
  - G칬r det enklare att f칬rst친 och anv칛nda ny teknologi
- L칛s b칬cker!
  - B친de tekniska och icke-tekniska b칬cker.
  - F칬rsta steget till att bredda dina kunskaper.
  - Tr칛ning i att h친lla fokus.
- Kritiskt t칛nkande
  - Kan detta st칛mma?
  - Vad 칛r k칛llan?
  - "Fem varf칬r"
** Kommunikation
- Ditt karri칛rval handlar om att kommunicera
  - Kommunicera med en dator
  - Kommunicera med dig sj칛lv
  - Kommunicera med ditt framtida sj칛lv
  - Kommunicera inom ditt team
  - Kommunicera med din chef
  - Kommunicera med andra utvecklingsteam
  - Kommunicera med Kunder och slutanv칛ndare
  - \dots

- Det visar sig att f칛rdighet i /spr친k/ 칛r viktigare 칛n f칛rdighet i matte f칬r att bli en bra programmerare.

Prat et al, "Relating Natural Language Aptitude to Individual
Differences in Learning Programming Languages". Scientific Reports,
2020.  https://www.nature.com/articles/s41598-020-60661-8

TL;DR: A study showing that the most important skills that facilitates
learning programming are short term memory and problem solving
(explaining 34% of the variance), and in second place language aptitude
(17%). Math skills was quite irrelevant (2%).
** Kommunikation
Det h칛r 칛r viktigt, s친 ett citat till:

#+begin_quote

Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to human
beings what we want a computer to do.

#+end_quote

-- Donald Knuth, 1984.

* En Pragmatisk Ansats
[Thomas & Hunt, Kapitel 2]

#+ATTR_ORG: :width 400
[[./arne01.png]]

- Designa f칬rst :: T칛nk igenom vad du skall g칬ra innan du g칬r det.
  - Easier To Change :: All bra design 칛r l칛ttare att 칛ndra 칛n d친lig design.
  - DRY; Don't Repeat Yourself :: Upprepning == sv친rare att 칛ndra
  - Isolera mot F칬r칛ndring :: Isolerat == l칛ttare att 칛ndra
  - Sikta mot det Os칛kra :: Utv칛rdera s친 mycket av designen som m칬jligt i varje cykel.
- Prototyper :: Billig utv칛rdering av din design
- Estimat :: Hur l친ng tid kommer det ta? Hur sv친rt 칛r det? Vad beh칬ver jag veta f칬r att avg칬ra detta?
** Easier to Change

#+begin_quote
*Bra Design 칛r l칛ttare att 칛ndra 칛n D친lig Design*
#+end_quote

- Vi designar f칬r /underh친llbarhet/
- Datorn begriper vad vi vill g칬ra 칛nd친
- Det skall vara l칛tt /f칬r oss m칛nniskor/ att 칛ndra /v친ra artefakter/
- F칬r칛ndring 칛r oundvikligt; designen m친ste t친la det.

Grundl칛ggande designprinciper, Objektorienterade designprinciper hj칛lper:
- Encapsulation
- Single Responsibility Principle
- Low Coupling
- High Cohesion
- \dots
** Don't Repeat Yourself
- Mjukvara byggs inte i en sittning.
- Det 칛r inte ett vackert planerat och fint broderat lappt칛cke.
- Snarare en h칬g med bl칬ta k칬kstrasor som har sl칛ngts i en h칬g under 40 친r.
- Varje nytt lager 칛r (Lientz et al. 1978):
  - f칬r칛ndrade krav,
  - uppdateringar f칬r att fixa gamla fel, eller
  - uppdateringar f칬r att h칛nga med en f칬r칛nderlig verklighet.

Det finns en stor risk att du upprepar gammal kod bara f칬r att du inte hittar den
- \dots Och du kan ge dig den p친 att den gamla koden kommer st칛lla till det f칬r dig.
- Upprepad kod == sv친rare att 칛ndra

*Inte bara programkod*
- Kunskap
- Avsikt
- Design
- L칬sning av samma problem
- Dokumentation
  - 칛ven dokumentation av koden (kommentarer i koden, Doxygen, osv.)
** Inkapsling
- Isolera delsystem, komponenter, klasser, mm. fr친n varandra
- Isolera funktionalitet fr친n varandra

- L칛ttare att designa, bygga, underh친lla, testa.
- L칛ttare att f칬rst친, l칛ttare att f칬rklara
- L칛ttare att byta fr친n en l칬sning till en annan.
  - L칛tt att ha en /Plan B/
  - /L칛ttare att 칛ndra designen/

*En stor del av kursen kommer handla om inkapsling i olika former*

* Overview of an Executing Program
** Important Parts of the Computer
#+begin_src ditaa :file Computer-Parts.png
  /----------+  +-----------------+  +----------------+
  | CPU      |  | RAM (Memory)    |  | Hard Disk      |
  | cGRE     |  |                 |  |                |
  +----------/  |                 |  |                |
                |                 |  |                |
                |                 |  |                |
                |                 |  |                |
                |           cBLU  |  | {s} cBLU       |
                +-----------------+  +----------------+

                /-----------------\
                | Display  cPNK   |
                |                 |
                |                 |
                \-----------------/
#+end_src

#+RESULTS:
[[file:Computer-Parts.png]]

- The CPU Executes all code
- The CPU reads the code from RAM
  - It may need to first fetch the code from storage (hard drive, disk, ~C:~, network drive, \dots)
  - It may output data to a drive, or to the display.
- Other inputs: keyboard, mouse, sensors, network packets, \dots
** The Operating System
#+begin_src ditaa :file OperatingSystem.png
  +-------------+    +-------------+    +-------------+    +-------------+
  | User        |    | User        |    | User        |    | User        |
  | Application |    | Application |    | Application |    | Application |
  |             |    |             |    |             |    |             |
  |             |    |             |    |             |    |             |
  | cGRE        |    | cGRE        |    | cGRE        |    | cGRE        |
  +-------------+    +-------------+    +-------------+    +-------------+
                                                               
  +----------------------------------------------------------------------+
  |                     Operating System                                 |
  |                                                             cBLU     |
  +----------------------------------------------------------------------+
                                                                  
  +----------------------------------------------------------------------+
  |                     Hardware                                cBLK     |
  +----------------------------------------------------------------------+
#+end_src

#+RESULTS:
[[file:OperatingSystem.png]]

The /Operating System/ is responsible for:
- Hardware Abstraction / Resource Management :: Provides an easy-to-use interface to all hardware.
- Interruption Management :: Handles interruptions, e.g. timer, disk, network, keyboard, mouse, etc.
- Process Management :: Divides the CPU time fairly across all user applications
- Memory Management :: Makes sure the executing program is available in RAM
  - Security :: Contains data so that other applications can not read it
- Device Management :: Reads and Writes from/to Devices, e.g.
  - Filesystem Management :: Reads and Writes from/to Disk
  - Network Management :: Reads and Writes from/to Network

** An Executing Program
#+begin_src ditaa :file Executing.png

         /---------+
         | CPU     |
         |    cGRE |
         +---------/
            ^ Read, Execute and Write to/from RAM
            |
  +---------|--------------------------------------------------+
  | RAM     v                                                  |
  |     +--------------------------------------------------+   |
  |     | 1001110100110110110101001001001011100100110...   |   |
  |     +--------------------------------------------------+   |
  |                                                            |
  +------------------------------------------------------------+
#+end_src

#+RESULTS:
[[file:Executing.png]]

Courtesy of the operating system, the executing program
- Appears to be alone on the CPU
- Appears that it alone has access to of all the memory
- /Encapsulation/ is an important design principle.
- *Process* == Executing Program
** From Humans to Computers
Three main cases:
1) Compile directly to executable program for your computer platform (e.g. C++)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Compile* to =runnable binary=
     - Load source code into memory
     - Translate to your computer platform
     - Save to disk as a binary
   - 游눹 *Execute* program
     - Load binary into memory
     - execute instruction by instruction
2) Compile to =bytecode=, i.e. a made-up computer platform (e.g. Java, Clojure)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Compile* to =bytecde=
     - Load source code into memory
     - Translate to your computer platform
     - Save to disk as a binary
   - 游눹 *Execute* program
     - Load bytecode into memory
     - Read each instruction, translate to your computer platform, and execute
3) Interpret program code directly (e.g. lisp, JavaScript, PHP)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Execute* program
     - Load source code into memory
     - Read each instruction, translate to your computer platform, and execute
** Readable source code
- *The source code is the only artefact intended to be readable by humans.*
  - It is read and modified often, so we should take care when writing it.
- We can use low-level languages, close to how the computer sees the world
  - e.g. Assembly language, C/C++
- We can use higher-level languages, closer to what we want the computer to perform
  - e.g. Java, JavaScript, Clojure, lisp
- We can use /compiled/ or /interpeted/ languages
  - Compiled languages /usually/ execute faster
  - Interpreted languages are /usually/ easier to edit on the fly (while they are running)
  - Some programming paradigms are more common in compiled languages, others are more common in interpreted languages
- We can use any text editor to write our program
  - We /should/ use an editor and development environment that help us write /and read/ our program.
** Summary
#+begin_verse
A *process* is an application that runs on a *processor* (or *CPU*).
A *processor* reads, executes, and writes to and from *memory* (or *RAM*).
A *thread* executes program code; there can be many *threads* in a *process*.
*Threads in a process* share the same memory.
*Processes* are (generally) not able to share memory with other *processes*.
The *operating system* safeguards the *hardware* and shares resources fairly to all *software*
The *operating system* allows the *process* to pretend like it is *alone on the computer*.

An *application* may consist of many processes and threads, running on one or several computers.
A *system* may also include other types of hardware, and even humans.
#+end_verse
* Sammanfattning
D. Thomas, A. Hunt, The Pragmatic Programmer, 20th Anniversary Edition, 2020. ISBN-10: 0-13-595705-2

- Kaptiel 1: En Pragmatisk Filosofi
- Kapitel 2: En Pragmatisk Ansats

- 칀tagandekultur
- Du arbetar i ett team
- Designa f칬r f칬r칛ndring
- Minska risker genom att sikta mot det os칛kra

- Vad 칛r det egentligen vi har att arbeta med?
  - Mjukvarukod som exekveras i en isolerad process
  - /Inkapsling/
* N칛sta F칬rel칛sning: Utvecklingsmilj칬n
- Thomas & Hunt; Kapitel 3: The Basic Tools
- Grunderna i Konfigurationshantering
- Installera och bli v칛n med din utvecklingsmilj칬

