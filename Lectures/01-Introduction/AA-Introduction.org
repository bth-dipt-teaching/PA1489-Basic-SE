#+Title: PA1489 Grundl칛ggande Mjukvaruutveckling 
#+Subtitle: Introduction
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2024-05-27
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t H:1 toc:nil
#+STARTUP: beamer

#+LATEX_CLASS_OPTIONS: [10pt,a4paper]
#+BEAMER_THEME: BTH_msv

* Introduktion
- Om Kursen
- En Pragmatisk Mjukvaruutvecklare
- En Pragmatisk Ansats
- Kort om exekverande program
* About Me: Mikael Svahnberg
#+ATTR_LATEX: :height 2cm
#+ATTR_ORG: :width 300
[[file:~/Documents/Personal/avatar.png]]


- Assistant Professor, PhD in Software Engineering
- mailto:Mikael.Svahnberg@bth.se
- https://sites.google.com/site/mikaelsvahnberg/
- Interests:
  - Software Architectures, Software Architecture Evaluation,
    Software Architecture Evolution, Requirements Engineering,
    Large Scale Requirements Engineering, Market-Driven Requirements Engineering,
    Software Product Lines, Software Reuse, Empirical Research Methodology,
    Software Engineering Decision Support, Static Code Analysis, Software Architecture Reconstruction
* Diskutera: Kursplan PA1489 :Discussion:
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

F칬ljande L칛randem친l examineras i kursen:

*Kunskap och F칬rst친else* Efter genomf칬rd kurs ska studenten kunna:
- Visa grundl칛ggande kunskaper i modern mjukvaruutveckling och containerbaserad mjukvaruutveckling genom att skriftligt beskriva och sammanfatta erfarenheter och observationer fr친n 칬vningar och projekt.

*F칛rdighet och f칬rm친ga*	Efter genomf칬rd kurs ska studenten kunna:
- Utifr친n en specifikation utveckla, dokumentera, och presentera ett mjukvaruprojekt som exekverar p친 ett f친tal kommunicerande containers.
- Fels칬ka ett program med hj칛lp av testkod och en debugger.
- Samarbeta runt ett gemensamt utvecklingsprojekt med hj칛lp av konfigurationsverktyg.
- Hantera de verktyg och utvecklingsmilj칬er som anv칛nds vid utveckling och fels칬kning med containerbaserad mjukvaruutveckling.

*V칛rderingsf칬rm친ga och f칬rh친llningss칛tt* 	Efter genomf칬rd kurs ska studenten kunna:
- Skriftligt reflektera 칬ver sina l칬sningar och sitt anv칛ndande av utvecklingsverktyg.
* M친l med Kursen I
- Ni har precis b칬rjat er v칛g till att bli Programvaruutvecklare
- Under de n칛rmaste 친ren kommer ni f칬rdjupa er i en stor m칛ngd teorier, principer, och teknologier.
  - Ni kommer bygga upp er egen /verktygsl친da/

- Den h칛r kursen ger en 칬versikt 칬ver vissa viktiga grunder i denna verktygsl친da
- Tekniker
  - konfigurationshantering
  - enhetstestning
  - kod-dokumentation
  - olika programmeringsspr친k
  - utveckling i och med virtuella maskiner
  - \dots
- Men ocks친 en grundl칛ggande filosofi:
  - En Pragmatisk Mjukvaruutvecklare
  - /Anv칛nd de verktyg som 칛r dig givna, och g칬r dem till dina egna/
* M친l med Kursen II
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- Kursen kommer /inte/ hinna g친 p친 djupet om mjukvaruutveckling eller n친gon enskild teknik.
  - ni har tre (plus tv친) 친r p친 er f칬r detta

M친let 칛r att ni skall:
- f친 upp 칬gonen f칬r vad som finns tillg칛ngligt
- f친 en insikt i hur olika teorier, principer, och teknologier passar ihop
- f친 /viss/ 칬vning i att anv칛nda de mest grundl칛ggande teknologierna

Cave!
- Mycket kommer verka sv친rt
- Du kommer kanske inte hinna l칛ra dig allt
- Du kommer kanske inte hinna g칬ra alla 칬vningar

** Det 칛r ok. Det 칛r t칛nkt s친.
Min f칬rhoppning:
- Kom ih친g att teknologierna /finns/, s친 att du kan anv칛nda dem senare, /n칛r du beh칬ver dem/
- F칬rs칬k etablera /n친gra/ goda, pragmatiska vanor redan nu, och bygg p친 efter hand.
- Kom tillbaka till det h칛r kursmaterialet om n친got 친r (n칛r du beh칬ver) och anv칛nd det som referensmaterial.
* Om F칬rel칛sningarna
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- F칬rel칛sningarna anv칛nder sig av en blandning av spr친k (svenska, engelska) och programspr친k.
- Spr친ket och spr친ken 칛r verktyg som du kommer anv칛nda dig av p친 olika vis under hela din studietid och din karri칛r.

| id | Inneh친ll                                 |
|----+------------------------------------------|
|  1 | Introduktion                             |
|  2 | 칐versikt 칬ver Utvecklingsmilj칬n          |
|  3 | Testning och Debuggning                  |
|  4 | Dokumentation av K칛llkod                 |
|  5 | Ett Kompilerat Spr친k: Java               |
|  6 | Anv칛ndargr칛nssnitt i Java                |
|  7 | Virtuella Maskiner och Containers        |
|  8 | Applikationsutveckling med Microservices |
|  9 | Ett Tolkat Spr친k: JavaScript             |
| 10 | Applikationsutveckling med JavaScript    |
| 11 | Introduktion till Databaser              |
| 12 | --Buffert--                              |
| 13 | --Buffert--                              |
| 14 | --Buffert--                              |
| 15 | --Buffert--                              |
| 16 | --Buffert--                              |
|----+------------------------------------------|
* Struktur p친 Kursen
- L칛rplatform :: Canvas
- F칬rel칛sningar :: ger en 칬versikt 칬ver 칛mnet och teorin.
- L칛sanvisningar :: inf칬r vissa f칬rel칛sningar, I andra fall bara ett 칛mne som ni kan f칬rbereda er fritt p친.
- 칐vningar :: om inneh친llet i varje f칬rel칛sning, g친r p친 djupet med det praktiska hantverket
- Inl칛mningsuppgifter :: s칛tter samman hantverket till en helhet.
- /Ingen tenta/

Varje vecka:
- 2 f칬rel칛sningar  2h
- 1 laboration  2h
- *Enskilt arbete* p친 egen hand eller i grupp.
* Kursliteratur
D. Thomas, A. Hunt, The Pragmatic Programmer, 20th Anniversary Edition, 2020. ISBN-10: 0-13-595705-2

#+ATTR_LATEX: :height 5cm
#+ATTR_ORG: :width 400
[[./Thomas-Hunt-2020-Pragmatic-Programmer.png]]

* Inl칛mningsuppgifter
- Tre inl칛mningsuppgifter om vardera 2.5hp:
  - Konfigurationshantering
  - Implementation och Dokumentation
  - Testning och Debuggning
- L칬s uppgifterna i grupper om 3--5 studenter
- Uppgifterna g친r hand i hand -- ni m친ste jobba med alla tre samtidigt
- Arbetet sker kontinuerligt under hela kursen med en stor inl칛mning i slutet av kursen.

Kompletteringar:
- Inom tv친 veckor efter att kursen slutar
- N칛r kursen ges n칛sta g친ng.
* 칐vningar, Inl칛mningsuppgifter och F칬rel칛sningar
- Mycket av det som beh칬vs f칬r att komma ig친ng med inl칛mningsuppgifterna g친s igenom tidigt i kursen.
  - I synnerhet inl칛mningsuppgift 1 och 3.
  - ... Men tyv칛rr inte allt: till Inl칛mningsuppgift 2 beh칬ver ni fler verktyg i er verktygsl친da.
- /B칬rja med vad ni kan/
  - L칬s vad ni redan kan l칬sa, planera resten.

- Anv칛nd 칬vningarna f칬r att l칛ra er hur ni skall l칬sa inl칛mningsuppgifterna.
- Ni kommer inte hinna bli v칛rldsb칛st p친 de teknologier som beh칬vs
  - Kopiera och anpassa i st칛llet.
  - Men *f칬rst친* vad ni kopierar!
* N친gra ord om AI
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

*"Who's the more foolish? The fool or the fool who follows it?"*
-- Obi Wan Kenobi

- Det g친r s칛kert f친 en bra b칬rjan p친 inl칛mningsuppgifterna fr친n en AI.
- Vad vinner ni p친 detta? L칛r ni er n친got? Hur vet ni att AI:n g칬r r칛tt?
- Det h칛r 칛r er framtida karri칛r, det 칛r det yrke ni sj칛lva har valt.
  - Vill /ni/ ha en utbildning, eller vill ni hellre ge den till en AI n친gonstans?
- 칐vningarna l칛mnas inte in, betygss칛tts inte, utan 칛r /bara/ till f칬r att ni skall ha en chans att l칛ra er n친got.
- Inl칛mningsuppgifterna har fokus p친 era l칛rdomar och reflektioner och kan komma att kompletteras med muntlig genomg친ng.

Dessutom:
- Framtiden kommer kr칛va /fler/ utvecklare med en /gedigen/ kunskap om programvaruutveckling, inte f칛rre.
- Man s칛tter inte en junior programmerare p친 att granska kod
- F칬retag kommer beh칬va folk som f칬rst친r vad AIn spottar ur sig, vilka s칛kerhetsbrister den har, och vad man skall g칬ra 친t det.

/Det h칛r 칛r ni/
* Verktyg
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

I den h칛r kursen beh칬ver du ha installerat:

- /Java/ , t.ex. OpenJDK https://openjdk.org/ 
- N친gon Utvecklingsmilj칬:
  - IntelliJ https://www.jetbrains.com/idea/
  - VS Codium https://vscodium.com/
  - Emacs https://www.gnu.org/software/emacs/
  - \dots
  - Vim https://www.vim.org/
- Ett Konfigurationshanteringsverktyg; Git https://git-scm.com/downloads
  - G칛rna n친got gr칛nssnitt f칬r git ocks친
- N친got verktyg f칬r att arbeta med l칛ttvikts-containrar
  - Podman https://podman.io/
  - Docker https://www.docker.com/


Du kanske ocks친 vill installera:
- /node.js/ lokalt: https://nodejs.org/en
- n친gon C/C++-kompilator, t.ex. gcc https://gcc.gnu.org/
- ett byggverktyg, s친som =make=
  - https://www.gnu.org/software/make/
  - https://cmake.org/ 
- n친got verktyg f칬r att modellera programvarudesign:
  - PlantUML http://plantuml.com/
  - IntelliJ https://www.jetbrains.com/help/idea/class-diagram.html
  - StarUML: http://staruml.io/
  - VisualParadigm https://www.visual-paradigm.com/
  - \dots
* En Pragmatisk Mjukvaruutvecklare / En Pragmatisk Filosofi
[Thomas & Hunt, Kapitel 1]

- /It's Your Life/ :: It's your career. Your choice. Be good at it. Improve.
- /Commitment Culture/ :: Take responsibilty for what you do.
- /We live in a Changing World/ :: Recognise change and prepare to handle it.
- /Trade-offs are Inevitable/ :: Learn to recognise what is /good enough/
- /You work in a Team/ :: A team consisting of current colleagues /as well as your future self/
  - Your commitment is to the team /and/ the customer.
  - Communicate with your team.
  - Keep your code tidy and improve it.
  - Fight the inevitable decay.
* 칀tagandekultur: Gruppen och Du
*Gruppens 친tagande 칛r ditt 친tagande -- alla beh칬vs*

#+ATTR_LATEX: :height 5cm
[[file:./IDogsleigh.jpg]]
* 칀tagande / Commitment Culture
 - *Gruppen* har 친tagit sig att leverera en produkt eller artefakt
   - Med en viss funktionalitet
   - Inom en viss budget
   - Vid en viss tidpunkt
   - Med en viss kvalitet
 - Som medlem i gruppen har *du* gjort samma 친tagande!

#+ATTR_LATEX: :height 4cm
 [[file:./IKennedy-AskNot.jpg]]
* Teamwork och Individens Ansvar
 - 칀tagandekultur
   - Gemensam f칬rst친else f칬r uppgiften
   - Individens 친tagande mot gruppen
   - Gruppens 친tagande mot individen

 - F칬ruts칛ttningar
   - Har du n칬dv칛ndig kunskap om uppgiften?
   - Har du f칬rm친ga och vilja att ta p친 dig ansvaret?
* Delaktighet
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- Gemensamma m친l
- Tillg친ng till n칬dv칛ndig information -- i tid
- F칬rst친else f칬r sammanhanget, individens bidrag till m친len
- M칬jlighet att uttrycka sin 친sikt
- M칬jlighet att p친verka sin situation
- Individuellt ansvar
  - f칬r /uppgiften/
  - f칬r /arbetss칛ttet/
  - f칬r /gruppen/

*N칛r det g친r fel:*
- Saknar gemensamma m친l, eller otydliga m친l
- Saknar styrning fr친n de som skall styra
- Saknar gemensamma processer, eller synkroniseringspunkter mellan processer
- Saknar 친tagande fr친n individerna
- Ingen tar eller avkr칛vs ansvar
- Ett f친tal dominerar diskussioner och beslut
- Beslut kommuniceras inte
- *\sum Kommunikationen fungerar inte*

* Entropi
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- Minnens i gymnasiefysiken?
- I mjukvara: /software rot/
  - Tecnical debt :: Snabbfix nu, vi lovar oss sj칛lva att fixa senare
  - Architecture erosion / architecture decay :: Vi gl칬mmer den ursprungliga tanken och b칬rjar ta genv칛gar

Resultat:
- Det tar l칛ngre och l칛ngre tid att g칬ra 칛ven enklare saker i koden.
- Mer tid g친r 친t att f칬rst친 vad man skall g칬ra och vad konsekvenserna blir
- Nyanst칛llda beh칬ver mer och mer tid p친 sig innan de kan bli produktiva
- Du blir mer och mer missn칬jd med ditt arbete

Olika orsaker:
- Vi hinner inte g칬ra r칛tt
- Vi minns inte vad som 칛r r칛tt
- Vi f칬rst친r inte av koden och/eller dokumentationen vad som 칛r r칛tt
- Det finns ingen dokumentation om vad som 칛r r칛tt
- Vi bryr oss inte om vad som 칛r r칛tt f칬r systemet eller resten av teamet

Fundamentalt f칬r att motarbeta mjukvarur칬ta: *Fixa det som 칛r trasigt*
- Forts칛tt bry er
- Visa f칬r resten av teamet att det spelar roll
- Visa i projektplanen att det tar tid och kostar
- Ta inte s칬nder saker n칛r du bygger nytt. *Testa din kod*
* Forts칛tt Utvecklas
- Programvaruteknik f칬r칛ndras st칛ndigt
  - Nya verktyg, nya teknologier, nya ramverk, nya programspr친k
- Sluta inte l칛ra dig n칛r du tar examen
- Kurserna h칛nger ihop: anv칛nd det du l칛rt dig hela tiden.
- Bredda dig: L칛r dig lite om mycket
  - G칬r det enklare att f칬rst친 och anv칛nda ny teknologi
- L칛s b칬cker!
  - B친de tekniska och icke-tekniska b칬cker.
  - F칬rsta steget till att bredda dina kunskaper.
  - Tr칛ning i att h친lla fokus.
- Kritiskt t칛nkande
  - Kan detta st칛mma?
  - Vad 칛r k칛llan?
  - "Fem varf칬r"
* Kommunikation
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- Ditt karri칛rval handlar om att kommunicera
  - Kommunicera med en dator
  - Kommunicera med dig sj칛lv
  - Kommunicera med ditt framtida sj칛lv
  - Kommunicera inom ditt team
  - Kommunicera med din chef
  - Kommunicera med andra utvecklingsteam
  - Kommunicera med Kunder och slutanv칛ndare
  - \dots

- Det visar sig att f칛rdighet i /spr친k/ 칛r viktigare 칛n f칛rdighet i matte f칬r att bli en bra programmerare.

Prat et al, "Relating Natural Language Aptitude to Individual
Differences in Learning Programming Languages". Scientific Reports, 2020.

 https://www.nature.com/articles/s41598-020-60661-8

** TL;DR:
A study showing that the most important skills that facilitates
learning programming are short term memory and problem solving
(explaining 34% of the variance), and in second place language aptitude
(17%). Math skills was quite irrelevant (2%).
* Kommunikation
Det h칛r 칛r viktigt, s친 ett citat till:

#+begin_quote

Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to human
beings what we want a computer to do.

#+end_quote

-- Donald Knuth, 1984.

* En Pragmatisk Ansats
[Thomas & Hunt, Kapitel 2]

#+ATTR_LATEX: :height 2cm
#+ATTR_ORG: :width 400
[[./arne01.png]]

- Designa f칬rst :: T칛nk igenom vad du skall g칬ra innan du g칬r det.
  - Easier To Change :: All bra design 칛r l칛ttare att 칛ndra 칛n d친lig design.
  - DRY; Don't Repeat Yourself :: Upprepning == sv친rare att 칛ndra
  - Isolera mot F칬r칛ndring :: Isolerat == l칛ttare att 칛ndra
  - Sikta mot det Os칛kra :: Utv칛rdera s친 mycket av designen som m칬jligt i varje cykel.
- Prototyper :: Billig utv칛rdering av din design
- Estimat :: Hur l친ng tid kommer det ta? Hur sv친rt 칛r det? Vad beh칬ver jag veta f칬r att avg칬ra detta?
* Easier to Change

#+begin_quote
*Bra Design 칛r l칛ttare att 칛ndra 칛n D친lig Design*
#+end_quote

- Vi designar f칬r /underh친llbarhet/
- Datorn begriper vad vi vill g칬ra 칛nd친
- Det skall vara l칛tt /f칬r oss m칛nniskor/ att 칛ndra /v친ra artefakter/
- F칬r칛ndring 칛r oundvikligt; designen m친ste t친la det.

Grundl칛ggande designprinciper, Objektorienterade designprinciper hj칛lper:
- Encapsulation
- Single Responsibility Principle
- Low Coupling
- High Cohesion
- \dots
* Don't Repeat Yourself
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

- Mjukvara byggs inte i en sittning.
- Det 칛r inte ett vackert planerat och fint broderat lappt칛cke.
- Snarare en h칬g med bl칬ta k칬kstrasor som har sl칛ngts i en h칬g under 40 친r.
- Varje nytt lager 칛r (Lientz et al. 1978):
  - f칬r칛ndrade krav,
  - uppdateringar f칬r att fixa gamla fel, eller
  - uppdateringar f칬r att h칛nga med en f칬r칛nderlig verklighet.

Det finns en stor risk att du upprepar gammal kod bara f칬r att du inte hittar den
- \dots Och du kan ge dig den p친 att den gamla koden kommer st칛lla till det f칬r dig.
- Upprepad kod == sv친rare att 칛ndra

*Inte bara programkod*
- Kunskap
- Avsikt
- Design
- L칬sning av samma problem
- Dokumentation
  - 칛ven dokumentation av koden (kommentarer i koden, Doxygen, osv.)
* Inkapsling
- Isolera delsystem, komponenter, klasser, mm. fr친n varandra
- Isolera funktionalitet fr친n varandra

- L칛ttare att designa, bygga, underh친lla, testa.
- L칛ttare att f칬rst친, l칛ttare att f칬rklara
- L칛ttare att byta fr친n en l칬sning till en annan.
  - L칛tt att ha en /Plan B/
  - /L칛ttare att 칛ndra designen/

*En stor del av kursen kommer handla om inkapsling i olika former*

* An Executing Program: Important Parts of the Computer
#+begin_src ditaa :file Computer-Parts.png
  /----------+  +-----------------+  +----------------+
  | CPU      |  | RAM (Memory)    |  | Hard Disk      |
  | cGRE     |  |                 |  |                |
  +----------/  |                 |  |                |
                |                 |  |                |
                |                 |  |                |
                |                 |  |                |
                |           cBLU  |  | {s} cBLU       |
                +-----------------+  +----------------+

                /-----------------\
                | Display  cPNK   |
                |                 |
                |                 |
                \-----------------/
#+end_src

#+ATTR_LATEX: :height 3cm
#+RESULTS:
[[file:Computer-Parts.png]]

- The CPU Executes all code
- The CPU reads the code from RAM
  - It may need to first fetch the code from storage (hard drive, disk, ~C:~, network drive, \dots)
  - It may output data to a drive, or to the display.
- Other inputs: keyboard, mouse, sensors, network packets, \dots
* The Operating System
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

#+begin_src ditaa :file OperatingSystem.png
  +-------------+    +-------------+    +-------------+    +-------------+
  | User        |    | User        |    | User        |    | User        |
  | Application |    | Application |    | Application |    | Application |
  |             |    |             |    |             |    |             |
  |             |    |             |    |             |    |             |
  | cGRE        |    | cGRE        |    | cGRE        |    | cGRE        |
  +-------------+    +-------------+    +-------------+    +-------------+
                                                               
  +----------------------------------------------------------------------+
  |                     Operating System                                 |
  |                                                             cBLU     |
  +----------------------------------------------------------------------+
                                                                  
  +----------------------------------------------------------------------+
  |                     Hardware                                cBLK     |
  +----------------------------------------------------------------------+
#+end_src

#+RESULTS:
[[file:OperatingSystem.png]]

The /Operating System/ is responsible for:
- Hardware Abstraction / Resource Management :: Provides an easy-to-use interface to all hardware.
- Interruption Management :: Handles interruptions, e.g. timer, disk, network, keyboard, mouse, etc.
- Process Management :: Divides the CPU time fairly across all user applications
- Memory Management :: Makes sure the executing program is available in RAM
  - Security :: Contains data so that other applications can not read it
- Device Management :: Reads and Writes from/to Devices, e.g.
  - Filesystem Management :: Reads and Writes from/to Disk
  - Network Management :: Reads and Writes from/to Network

* An Executing Program
#+begin_src ditaa :file Executing.png

         /---------+
         | CPU     |
         |    cGRE |
         +---------/
            ^ Read, Execute and Write to/from RAM
            |
  +---------|--------------------------------------------------+
  | RAM     v                                                  |
  |     +--------------------------------------------------+   |
  |     | 1001110100110110110101001001001011100100110...   |   |
  |     +--------------------------------------------------+   |
  |                                                            |
  +------------------------------------------------------------+
#+end_src

#+RESULTS:
[[file:Executing.png]]

Courtesy of the operating system, the executing program
- Appears to be alone on the CPU
- Appears that it alone has access to of all the memory
- /Encapsulation/ is an important design principle.
- *Process* == Executing Program
* From Humans to Computers
:PROPERTIES:
:BEAMER_OPT: shrink=5
:END:

Three main cases:
1) Compile directly to executable program for your computer platform (e.g. C++)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Compile* to =runnable binary=
     - Load source code into memory
     - Translate to your computer platform
     - Save to disk as a binary
   - 游눹 *Execute* program
     - Load binary into memory
     - execute instruction by instruction
2) Compile to =bytecode=, i.e. a made-up computer platform (e.g. Java, Clojure)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Compile* to =bytecde=
     - Load source code into memory
     - Translate to your computer platform
     - Save to disk as a binary
   - 游눹 *Execute* program
     - Load bytecode into memory
     - Read each instruction, translate to your computer platform, and execute
3) Interpret program code directly (e.g. lisp, JavaScript, PHP)
   - 游땏 *Write* Source Code and save to disk
   - 游눹 *Execute* program
     - Load source code into memory
     - Read each instruction, translate to your computer platform, and execute
* Readable source code
- *The source code is the only artefact intended to be readable by humans.*
  - It is read and modified often, so we should take care when writing it.
- We can use low-level languages, close to how the computer sees the world
  - e.g. Assembly language, C/C++
- We can use higher-level languages, closer to what we want the computer to perform
  - e.g. Java, JavaScript, Clojure, lisp
- We can use /compiled/ or /interpeted/ languages
  - Compiled languages /usually/ execute faster
  - Interpreted languages are /usually/ easier to edit on the fly (while they are running)
  - Some programming paradigms are more common in compiled languages, others are more common in interpreted languages
- We can use any text editor to write our program
  - We /should/ use an editor and development environment that help us write /and read/ our program.
* Summary
#+begin_verse
A *process* is an application that runs on a *processor* (or *CPU*).
A *processor* reads, executes, and writes to and from *memory* (or *RAM*).
A *thread* executes program code; there can be many *threads* in a *process*.
*Threads in a process* share the same memory.
*Processes* are (generally) not able to share memory with other *processes*.
The *operating system* safeguards the *hardware* and shares resources fairly to all *software*
The *operating system* allows the *process* to pretend like it is *alone on the computer*.

An *application* may consist of many processes and threads, running on one or several computers.
A *system* may also include other types of hardware, and even humans.
#+end_verse
* Sammanfattning
D. Thomas, A. Hunt, The Pragmatic Programmer, 20th Anniversary Edition, 2020. ISBN-10: 0-13-595705-2

- Kaptiel 1: En Pragmatisk Filosofi
- Kapitel 2: En Pragmatisk Ansats

- 칀tagandekultur
- Du arbetar i ett team
- Designa f칬r f칬r칛ndring
- Minska risker genom att sikta mot det os칛kra

- Vad 칛r det egentligen vi har att arbeta med?
  - Mjukvarukod som exekveras i en isolerad process
  - /Inkapsling/
* N칛sta F칬rel칛sning: Utvecklingsmilj칬n
- Thomas & Hunt; Kapitel 3: The Basic Tools
- Grunderna i Konfigurationshantering
- Installera och bli v칛n med din utvecklingsmilj칬

