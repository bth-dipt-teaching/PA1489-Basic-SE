#+Title: User Interfaces in Java
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2024-02-20
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t H:2
#+STARTUP: beamer

#+LATEX_CLASS_OPTIONS: [10pt,t,a4paper]
#+BEAMER_THEME: BTH_msv


* Introduktion
- Anv√§ndargr√§nssnitt i Java
  - textbaserade gr√§nssnitt
  - Grafiska gr√§nssnitt med Java AWT/Swing
- Enkel filhantering i Java
- Felhantering, =try-catch=, felrapportering
* Gr√§nssnitt
- /Gr√§nssnitt/ √§r en n√•got √∂veranv√§nd term
  - Komponenter erbjuder /programmeringsgr√§nssnitt/ som man anv√§nder n√§r man skriver kod
    - API :: Application Programming Interface
  - Klasser erbjuder ett /publikt gr√§nssnitt/
    - De publika metoder och attribut som man kan anv√§nda p√• objekt
  - Paket erbjuder ocks√• ett /publikt gr√§nssnitt/
    - De publika klasser som man kan anv√§nda sig av utifr√•n paketet
  - Servrar erbjuder ett /gr√§nssnitt/, ett API
    - De anrop man kan g√∂ra mot servern
    - Vanligt idag √§r ett /REST-API/, som man ofta g√∂r √∂ver /HTTP/
* Anv√§ndargr√§nssnitt
- /Anv√§ndargr√§nssnitt/ √§r det s√§tt som en /anv√§ndare/ kommer √•t ett system
  - UI :: User Interface
    - Parametrar p√• kommandoraden
    - Utskrifter i ett terminalf√∂nster
    - In- och Ut-matning i ett terminalf√∂nster
    - L√§sa och Skriva till filer (√§r det till f√∂r anv√§ndaren?)
    - TUI :: Text-based User Interface
      - "Fullst√§ndigt" anv√§ndargr√§nssnitt, fast bara med text, och tillg√§ngligt i en terminal
    - GUI :: Graphical User Interface
      - "F√∂nster och knappar"
* Exempel p√• Textbaserade gr√§nssnitt
- De flesta Unix-kommandon (ex ~ls -al~ , ~curl https://www.zombo.com~) tar parametrar och skriver ut en massa text
- N√•gra startar en interaktiv milj√∂ (ex /GNU debugger/ ~gdb~ )
- N√•gra skapar ett textbaserat UI, (ex filhanteraren /Midnight Commander/ ~mc~, editorn ~vi~ , eller ~emacs -nw~ )

F√∂rdelar:
- De fungerar alltid
- De fungerar √§ven n√§r du k√∂r dem p√• en annan maskin (e.g. via ~ssh~)
- De fungerar √§ven n√§r Windows-milj√∂n -- av olika anledningar -- kanske inte kan starta.

Nackdelar:
- Sv√•rare att "uppt√§cka" hur de fungerar
- Kr√§ver lite mer tanke f√∂r att konstruera f√∂r att de skall bli enkla
- Begr√§nsat med information som f√•r plats p√• 80x25 tecken
* Grafiska Anv√§ndargr√§nssnitt
#+begin_src plantuml :file gui-ex.png
@startsalt
!theme bluegray

{
{* File | Edit | Tools }
.
{/ <b>Selection | Execution | Result }
{+
{
Will you answer "No" to this question:
() Yes
() No
}
{
Please motivate your answer:
{SI
 .
 .
 "                              "
}
}
}
{ [Submit] | [Cancel] }
}
@endsalt
#+end_src

#+RESULTS:
[[file:gui-ex.png]]

- Skrivbordsapplikationer
  - Qt
  - Gnome
  - \dots
  - Java Swing/Java AWT
- Webapplikationer
* Att Kunna Byta Gr√§nssnitt
- En bra grundprincip √§r att man skall bygga ett system s√• att man kan /byta gr√§nssnitt/
- Separera /logik/ fr√•n /Presentation/
- =Model -- View=
- I praktiken byter man s√§llan gr√§nssnitt, men det ger ocks√• en tydligare design och √§r l√§ttare att underh√•lla.

- Ibland anv√§nder sig ett "vackrare" gr√§nssnitt av ett "enklare" under, en s.k. /porcelain/
  - (Linus Torvalds √§r, som s√• ofta, ursprunget till denna analogi: Man sitter inte direkt p√• avloppsr√∂ret)
  - Din utvecklingsmilj√∂ kan mycket v√§l anv√§nda ~gdb~ internt
  - Den anv√§nder ocks√• n√§stan s√§kert kommandorads- ~git~ undertill

* In- och utmatning i Java
- Klassen ~System~ √§r alltid tillg√§nglig
- I synnerhet ~System.out.print()~ och ~System.out.println()~ 
- ~System.out~ √§r en ~PrintStream~ som normalt h√§nvisar till standard output (terminalen)
- L√§s mer om ~PrintStream~ i java-dokumentationen:
  - https://docs.oracle.com/en/java/javase/20/docs/api/index.html
  - https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PrintStream.html

- ~System.in~ √§r en ~InputStream~, men den √§r sv√•rare att anv√§nda
- Anv√§nd hellre ~Console~ , som du f√•r tag i genom att anropa ~System.console()~.

#+begin_src java
  import java.io.*;
  Console con = System.console();

  System.out.print("Enter your name: ");
  String name = con.readLine();
  System.out.println("Hello " + name);

  // Or, shorter
  name = con.readLine("Please enter your name again: ");
  System.out.println("Hello again, " + name);

  // We can complicate things
  String lastname = con.readLine("What is your lastname, %s? ", name);
  con.printf("Greetings, %s %s!\n", name, lastname);
#+end_src
* Grafiska Gr√§nssnitt i Java
- Tv√• generationer: =java.awt= och =java.Swing=
  - AWT √§r √§ldre, men byggt specifikt f√∂r varje platform/operativsystem   
  - Swing √§r skrivet i och f√∂r Java
  - De flesta klasser som anv√§nds b√∂rjar med bokstaven "J": JFrame, JPanel, JLabel, \dots
  - De flesta finns ocks√• i flera varianter, t.ex. dekorerade med scrollbars.

#+begin_src dot :file swing.png

digraph {
rankdir=LR;
size=10;
Object
node [shape=rectangle,style="filled,rounded",fillcolor=lightyellow];
Window, Container, Component
node [style="filled,rounded",fillcolor=lightblue];
JFrame -> Frame -> Window -> Container -> Component -> Object
JLabel, JList, JText, JMenuBar, JOptionPane, JScrollbar, AbstractButton, JPanel -> JComponent -> Container
JTextField, JTextArea -> JText
JToggleButton, JMenuItem, JButton -> AbstractButton
JMenu -> JMenuItem
JCheckBox, JRadioButton -> JToggleButton
}

#+end_src

#+RESULTS:
[[file:swing.png]]
* JFrame, JPanel, och LayoutManagers
#+begin_src java
		JFrame window = new JFrame("JavaPonies");
		window.setSize(width, height);

		JPanel canvas = new JPanel();		
		window.getContentPane().add(canvas);
		canvas.setLayout(new BorderLayout());
		canvas.add("North", /* ... */);
#+end_src

- ~JFrame~ f√∂r att skapa ett f√∂nster
  - Stoppa in en ~JPanel~ som inneh√•ller allt GUI
  - L√§gg till Menyer osv.
- Kan ha godtyckligt m√•nga ~JPanel~; en ~JPanel~ kan i sin tur ocks√• inneh√•lla flera ~JPanel~.
- Varje ~Container~ kan ha en ~LayoutManager~ som styr hur man vill l√§gga in komponenter i den.
  - BorderLayout ::
    - North, South, East, West, Center
    - =BorderLayout.PAGE_START=, =PAGE_END=, =LINE_START=, =LINE_END=, =CENTER=
  - BoxLayout :: En rad eller en kolumn
    - ~new BoxLayout(thePanel, BoxLayout.PAGE_AXIS)~ eller ~BoxLayout.LINE_AXIS~
  - CardLayout :: olika "kort", d√§r ett i taget √§r synligt.
  - FLowLayout :: en l√•ng rad med komponenter
  - GridLayout :: en =MxN= matris av "h√•l" att stoppa komponenter i.
  - GridBagLayout :: Mer komplicerad GridLayout
  - SpringLayout :: L√•ter begr√§nsningar f√∂r varje komponent styra hur de l√§ggs ut.

* En egen Panel
- Man kan √§rva och ut√∂ka alla Swing-komponenter.
- Mest anv√§ndbart √§r det att √§rva fr√•n ~JPanel~ och bygga sin egen komponent
  - Till exempel om man vill ha ett "kort" p√• en Ponny som man kan anv√§nda i ett f√∂nster, se ~view.PonyCard~
  - Vill man ha ett helt eget f√∂nster s√• kan man √§rva och ut√∂ka fr√•n ~JFrame~ , se t.ex. klassen ~view.PonyWindow~

#+begin_src java
  private class Banner extends JPanel {
    public Banner() {
      super(); 										// Se till att all JPanel-initiering g√∂rs.
      setPreferredSize(new Dimension(width, 50));
    }

    public void paintComponent(Graphics g) {
      g.setColor(Color.black);
      g.setFont(new Font("SansSerif", Font.BOLD, 20));
      g.drawString("Java Ponies", 20, 40);
      /* ... */
    }
  }
#+end_src
* paint()
- Vid behov anropas ~repaint()~
  - I sin tur anropar denna ~paint()~
    - ... som anropar ~paintComponent()~, ~paintBorder()~, och ~paintChildren()~
- ~paint()~ kan √∂verlagras f√∂r att rita sin egen komponent.

#+begin_src java
  public void paint(Graphics g) {
    super.paint(g); 							// Om man vill att alla dekorationer och underkomponenter skall ritas ut.

    // Graphics (eller Graphics2D) har en massa metoder f√∂r att rita former och text
    // l√§s g√§rna mer i dokumentationen om dessa.
    g.drawImage(myImage, 0, 50, getBackground(), this);
    g.setColor(Color.black);
    g.drawRoundRect(0,0,width-1, height-1, 5, 5);		
    g.drawString(myPony.getName(), 5, 20);

    g.dispose()										// Var sn√§ll och "sl√§pp" Graphics-objektet efter dig, s√• vet Java att det inte blir mer ritat.
  }
#+end_src
* EventListerners
- En ~Component~ kan skapa olika typer av /H√§ndelser/ (Events), till exempel:
  - Focus
  - Key
  - Mouse
  - MouseMotion
  - Action
- Till var och en av dessa h√§ndelser kan man koppla en /EventListener/
  - FocusListener, KeyListener, MouseListener, ActionListerner, osv.
  - ~addMouseListener(...)~, ~addActionListener(...)~, \dots
  - En /EventListener/ har ett antal metoder som anropas n√§r h√§ndelsen intr√§ffar
  - Varje metod i /EventListenern/ tar en parameter, som representerar h√§ndelsen,
    - e.g. ~ActionEvent~, ~MouseEvent~, osv.
- ActionListener, MouseListener, osv. √§r /interface/, du m√•ste skriva implementationen f√∂r dem.
  - Ibland bara en enda metod, ibland en handfull.
  - Det blir otydligt att skriva en massa tomma metoder f√∂r de h√§ndelser du /inte/ √§r intresserad av.
  - Numera finns f√§rdiga implementationer /xxxAdapter/ som du kan ut√∂ka med bara de beteenden du vill.
    - (Inkonsekvent nog finns bara /xxxAdapter/ f√∂r de Listeners som har mer √§n en metod üò†)

* EventListeners och Klasser
T√§nk dig f√∂ljande scenario:
- Du har ett gr√§nssnitt, med tv√• knappar i.
- Du vill (s√•klart) veta n√§r man trycker p√• en knapp, och helst vilken knapp man trycker p√•.

Olika l√∂sningar:
1. Skriv en separat klass som ~implements ActionListener~
   - Du kollar noga p√• det ~ActionEvent~ du f√•r som parameter i ~actionPerformed()~ - metoden.
   - Den h√§r klassen m√•ste allts√• veta exakt vad alla knappar heter.
   - ~ActionListener~ √§r enkel, den har bara en metod; titta p√• t.ex. ~MouseListener~ med fem metoder.
   - Ditt paket f√•r minst en s√•dan h√§r klass som bara finns f√∂r att ta emot en enda h√§ndelse.
     - Jobbigare att l√§sa; din GUI-klass har inte l√§ngre hela ansvaret.
2. Skriv en /n√§stlad och privat klass/ som ~implements ActionListener~ p√• samma s√§tt
   - Inga fler separata klasser; den h√§r koden kommer skrivas som en del av din GUI-klass.
   - I √∂vrigt samma som (1)
3. Anv√§nd ~ActionListener~ som bas och √∂verlagra metoden med lite moderna genv√§gar:

#+begin_src java
  JButton b1 = new JButton("Confirm");
  JButton b2 = new JButton("Cancel");
  JTextField someText = new JTextField();

  b1.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        // Read data from window (all local variables are available)
        someText.getText();
      } });

  b2.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        someText.setText("");
      } });

  // MouseListener har fler metoder, allts√• finns det en MouseAdapter ocks√•...
  myCanvas.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent evt) {
          if (null == myWindow) {
            myWindow = new PonyWindow(myPony);
            myWindow.setVisible(true);
          } else {
            myWindow.toggleVisible();
          }
        } });
#+end_src

* File Output in Java
- Use ~java.io.FileWriter~ 
- There are many other ways, e.g. ~java.io.PrintWriter~
- Careful about the character set, √•√§√∂ may trip you up.

Basic pattern:
- ~try { 1. Open, 2. Write, 3. Close } catch(IOException e) {}~
- What if we fail while writing?
- What happens with close?

Preferred pattern ~try-with~
- ~try (resources to use ) { } catch( ... ) { }~
- Calls ~close()~ for you even if there is an exception.

#+begin_src java :file Outputter.java
  import java.io.FileWriter;
  import java.io.PrintWriter;

  public class Outputter {
    public void basicPattern(String filename) {
      try {
        FileWriter fw = new FileWriter(filename);        
        fw.write("Some text\n");
        fw.append("Some more text\n");
        fw.close();
      } catch(IOException e) {
        System.err.println("Error writing file " + filename);
        e.printStackTrace();
      }
    }

    public void preferredPattern(String filename) {
      try(FileWriter fw = new FileWriter(filename);
          BufferedWriter buf = new BufferedWriter(fw); ) {
        buf.write("Some preferred text");
        buf.newLine();
        buf.write("Some more preferred text");
      } catch (IOException e) {
        System.err.println("Error writing file " + filename);
        e.printStackTrace();
      }
    }

    public void otherWriter(String filename) {
      try ( PrintWriter out = new PrintWriter(filename)  ) {
        out.println("Some more more text");
        out.println("and yet some more");
      } catch(IOException e) {
        System.err.println("Error writing file " + filename);
        e.printStackTrace();
      }
    }


    public static void main(String [] args) {
      Outputter o = new Outputter();

      o.basicPattern("tst.txt");
      o.preferredPattern("tst2.txt");
      o.otherWriter("tst3.txt");
    }

  }
#+end_src

#+RESULTS:
* File Input in Java
- ~java.io.FileReader~ ?
  - Only has one method to read a single character.
  - ~java.io.BufferedReader~ to get ~readLine()~ method

- Two ways here too. One old-school and one newer.
- As usual, there are many other ways too.

#+begin_src java :file Inputter.java
  import java.io.FileReader;
  import java.io.BufferedReader;
  import java.nio.file.*;
  import java.util.ArrayList;

  public class Inputter {

    public ArrayList<String> oldSchool(String filename) {
      ArrayList<String> contents = new ArrayList<String>();
      try (
        FileReader file = new FileReader(filename);
        BufferedReader buf = new BufferedReader(file);
        ) {
        String line;
        while ((line = buf.readLine()) != null) {
          contents.add(line);
        }
      } catch (IOException e) {
        System.out.println(e);
      }

      return contents;
    }

    public ArrayList<String> hipster(String filename) {
      ArrayList<String> contents = new ArrayList<String>();
      Path path = Paths.get(filename);

      try(BufferedReader buf = Files.newBufferedReader(path)) {
        String line;
        while ((line = buf.readLine()) != null) {
          contents.add(line);
        }
      } catch (IOException e) {
        System.out.println(e);        
      }

      return contents;
    }

    public static void main(String [] args) {
      Inputter in = new Inputter();
      ArrayList<String> contents;

      contents = in.oldSchool("tst.txt");
      for (String l : contents) { System.out.println(l); }

      contents = in.hipster("tst2.txt");
      for (String l : contents) { System.out.println(l); }

    }
  }

#+end_src

#+RESULTS:
: Some text
: Some more text
: Some preferred text

* Java Readers and Writers
- Conceptually, you wrap different levels of readers until you get the functionality you want
  - Typically, you will want at least a ~BufferedReader~ and a ~BufferedWriter~

#+begin_src plantuml :file readers.png
object "in:BufferedReader" as in
object "fileIn:FileReader" as filein
in o-- filein

object "out:BufferedWriter" as out
object "fileout:FileWriter" as fileout
out o-- fileout
#+end_src

#+RESULTS:
[[file:readers.png]]

- Reader
  - BufferedReader 
  - CharArrayReader 
  - FilterReader 
  - InputStreamReader 
    - FileReader
  - PipedReader 
  - StringReader 

- Writer
  - BufferedWriter 
  - CharArrayWriter 
  - FilterWriter 
  - OutputStreamWriter
    - FileWriter
  - PipedWriter 
  - StringWriter 
  - PrintWriter

* When Things Go Wrong: Testing for Runtime Errors
- Compile-time errors covered previously:
  - Syntax Errors
    - the compiler tells you what you have written wrong
    - Read the compiler errors
  - Logical Errors
    - the compiler does not know this is wrong
    - Use Unit Testing to capture this.
    - Debugger

- Runtime errors :
  - Input Testing
    - Ensure that user enters "correct" information
  - Exception handling
    - runtime exceptions
    - e.g. "file not found", "divide by zero", \dots
* Handling Runtime Errors
- Handling compile-time errors is done during development
- Handling errors caught by automated tests is done during development
- Handling runtime errors /have to be/ handled during runtime!
* A Software Tester Walks into a Bar\dots
A Software Tester walks into a bar and orders a beer. Then they orders:
- -1 beers
- 999999999 beers
- a duck
- 0 beers
- sdlkfjhkjsdhgfk
- null

So far, so good. Then they:
- Orders 3 friends to come over for some fun.
- Unhooks the tap and orders a beer.
- Breaks all the glassware and orders a beer.
- Sets the bar on fire and orders a beer.
- Orders someone else a beer.
- Has everyone order a beer.
- Orders in russian.
- Orders a beer for later.
- Orders every beer.
- Walks into the bar backwards.
- Runs into the bar.
- Sits at the bar overnight doing nothing to see what happens.
- Tries to sell a beer.
- Quickly orders a second beer before the first is served.
- Interrupts the order midway and walks out.
- Orders a beer in IE6.
- Orders 1 ; select * from liquors; ‚Äî beers.
- Orders an apostrophe and walks out without paying the bill.
- Waits for someone else to order, stands between them and the bartender, takes the drink.

... then sends them all back.
* Detecting the Error
- Defensive Programming
  - Balance between checking everything and put reasonable trust in the program.

- Anticipating and avoiding the error 
- Detecting the error state
- Deciding what to do about the error
- Deciding how much to report to the user
* A Brief Word on Input Sanitisation
- Never ever /ever/ assume that input is correct
  - User input
  - Command line parameters
  - File contents
  - Socket traffic
  - Fetched data (e.g., html, xml, json)
  - HTTP header
  - Properties/Config files
  - \dots
  - https://github.com/kuronpawel/big-list-of-naughty-strings

- Java is safer than C++, but can still be really dangerous.
  - What do you do with the input?
    - Pass it on as a field to the database?
    - Display it in a web browser?
    - Use it as a script and interpret it?
  - What do you do if not all data is present?
  - What do you do if the data is of the wrong type?
* Method Input: Parameters
- Are the parameters to a method within bounds?
- Are the parameters not null?
  - Are there good defaults to use instead?
- Will the method complete even with incorrect parameters?
- Will the result be meaningful?
* Error Reporting (to the user)
- Is the error quietly fixable?
- Should the user be /informed/ , or /warned/
- Should the program /exit/?
- Write to a log to facilitate debugging

#+begin_src java :imports java.util.logging.*
  int x = 10;
  Logger l = Logger.getLogger("se.bth.example.system.Test");
  l.entering("Main","main()");

  l.setLevel(Level.ALL);
  l.info("Current log level " + l.getLevel());

  l.config("Using default configuration");
  l.info("Starting...");

  l.log(Level.FINE, "Still here...");
  l.fine("Also still here");

  l.warning("Not sure how to proceed here");

  l.exiting("Main", "main()");
#+end_src
* Error Reporting (within program)
- Magic return value that indicates error
  - ~null~
  - ~-1~
  - ~false~
- Throw an Exception (Will it be caught ‚ÅâÔ∏è)
- Set an error flag somehwere
- \dots
* Error Handling
- Check for magic error number
- Catch Exception
- Check error flags

- Deal with the error if possible
  - Maybe return some indication that there was an error
  - Log the error
- Maybe re-try the same operation
  - How many times?
  - Delay between each try?
- When all fails: re-throw exception

- *Always* clean up when you detect an error!
  - If you tried to open a file, try to close it
  - If you had an open database connection, close it
  - \dots

* Sammanfattning
- Anv√§ndarinteraktion kan g√∂ras i olika niv√•er
  - start-parametrar och utskrifter
  - in- och utmatning i en konsol
  - text-baserat UI
  - Grafiska gr√§nssnitt
  - web-applikationer

- =Java.Swing= f√∂r att bygga grafiska gr√§nssnitt i Java
  - Finns naturligtvis verktyg f√∂r detta, men √§r ganska enkelt att skriva sj√§lv
- =EventListeners= f√∂r att binda samman GUI-kod med din applikation

- In-och utmatning till filer
- Felhantering, =try-catch=, felrapportering
* N√§sta F√∂rel√§sning
- Virtuella Maskiner och Containers
- Utveckla i en Container
- Utvecklingsprocess f√∂r Kompilerade respektive Tolkade programspr√•k
* √ñvning: Mera Pony-Statistik
- I projektet JavaPonies finns en branch =PonyStatistics= d√§r interfacet fr√•n tidigare f√∂rel√§sningar implementeras.
- Checka ut JavaPonies p√• ett nytt st√§lle (om du vill spara din implementation) och byt branch:
  - ~git clone https://codeberg.org/mickesv/JavaPonies.git~
  - ~cd JavaPonies && git checkout PonyStatistics~
- Kontrollera vad som √§ndrats: ~git diff origin/main~
** En Ny Main
1. Skriv en ny klass ~JavaPonyStatistics extends JavaPonies~
  (att √§rva fr√•n JavaPonies g√∂r att du kan spara mycket av uppstarten fr√•n JavaPonies).
2. Skriv en ny ~main()~ - funktion i ~JavaPonyStatistics~ :

#+begin_src java
	public static void main(String[] args) {
		JavaPonyStatistics ps = new JavaPonyStatistics();
		ps.printStatistics();
	}
#+end_src

3. [@3] Implementera metoden ~JavaPonyStatistics.printStatistics() s√• att den:
   - itererar √∂ver alla Ponies (du hittar dem via ~myPonies.findAll()~ ), och 
   - skriver ut Categories, Behaviour Groups, Behaviours, Effects, Interactions, och Speakig Lines:

#+begin_verse
Printing Statistics for Apple Bloom
Categories:
Behaviour Groups:
Behaviours: stand, walk, follow_aj, spin_me_right_round, workout, aww, CMC, dance
Effects:
Interactions:
Speaking lines:
- CUTIE MARK CRUSADER DESKTOP PONIES!!!
- Did I get my cutie mark? Did I? Did I!?
- Scoot-Scootalooo!
- Aww!
- Aren't you gonna stay for brunch?
- But I want it now!
- I am a big pony!
- I'm not a baby, I can take care of myself!
- Likely story.
- Not the cupcakes!
- Some pony needs to put this thing out of its misery.
- You're not using power tools, are you?
- Scootaloo! Scoot-Scootaloo!
- Trust me.
- What a thing to say!
#+end_verse
** Bara en enda Pony
Notera signaturen f√∂r main: ~public static void main(String [] args)~
- public :: s√• att man kommer √•t den utanf√∂r klassen
- static :: s√• att man inte beh√∂ver f√∂rst skapa ett objekt
- void :: man kan inte returnera n√•got
- main :: s√• att runtime-java vet vilken metod den skall leta efter
- String [] args :: H√§r kommer alla kommandorads-parametrar.

Dags att l√§gga till lite interaktivitet:
1. Om ~(0 == args.length)~ , lista statistik f√∂r alla ponies (som tidigare)
2. Annars, hitta alla ponies som inneh√•ller ~arg[0]~.
   - Du kommer vilja se till att allting √§r antingen stora eller sm√• bokst√§ver: ~String::toLowerCase()~ .
   - Det r√§cker att veta om ponnyns namn /inneh√•ller/ str√§ngen, anv√§nd ~String::contains()~ .
   - ~pony.getName().toLowerCase().contains(arg[0].toLowerCase())~
** Ett Grafiskt Gr√§nssnitt
1. Skriv en ny klass ~view/PonyStatisticsViewer~ som skapar en JFrame enligt nedan.
2. Skriv en funktion f√∂r att fylla listan med namnen p√• alla tillg√§ngliga Ponies.
3. Skriv kod s√• att n√§r man har valt en Pony och trycker p√• knappen "View Statistics", s√• visas statistiken till h√∂ger.
4. V√§nta med "Save to file..." - knappen.

#+begin_src plantuml :file PonyStatsViewer.png
@startsalt
!theme bluegray

{^
{
<b>Pony Statistics Viewer
}
{^"Available Ponies"
{SI
Rainbow Dash
Pinkie Pie
<b>Applejack
Twilight
.
.
.
.
.
.
"                              "
}
[View Statistics] 
} | {^"Pony Statistics"
 Name |             "Applejack           "
 Behaviour Groups | "                    "
 Behaviours |       "stand, walk, gidd..."
 Effects |          "Apple Drop, tree_..."
 Interactions |     "                    "
 .
 Speaking Lines | {SI
  Hey there, Sugarcube!
  Howdy, Partner!
  I better get buckin' soon.
  Yeee...
  Haw!
}
. | [Save to file...]
}
}



#+end_src

#+RESULTS:
[[file:PonyStatsViewer.png]]

** Save to File...
Nu √§r det dags att implementera "Save to file...":

1. N√§r man trycker p√• knappen skall en ~javax.swing.JFileChooser~ √∂ppnas.
2. Statistiken om den valda Ponyn skall sedan skrivas till den angivna filen.
3. Kontrollera att filen har r√§tt inneh√•ll genom att √∂ppna den (eller visa den i din terminal)

*** MWE for Save to File
#+begin_src java
import javax.swing.*;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.swing.filechooser.FileSystemView;

public class FiCH {

public static void main(String [] args) {
	JFrame f = new JFrame("FiCH");
	f.setSize(500, 500);
	f.setVisible(true);
	JLabel l = new JLabel("no file selected");

	JButton button1 = new JButton("save");  
  button1.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
				JFileChooser j = new JFileChooser(FileSystemView.getFileSystemView().getHomeDirectory());
				int result = j.showSaveDialog(f);
				if (result == JFileChooser.APPROVE_OPTION) {
					l.setText(j.getSelectedFile().getAbsolutePath());
				} else {
					l.setText("the user cancelled the operation");
        }
			} });
 
	JPanel p = new JPanel();
	p.add(button1);
	p.add(l);
	f.add(p);	
}
}
#+end_src
